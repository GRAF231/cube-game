# Система компонентов

## Обзор компонентной структуры

Проект "Тетрис-блоки" использует компонентную архитектуру для разделения ответственности и улучшения поддерживаемости кода. Основная игровая сцена (`GameSceneNew.ts`) координирует работу нескольких специализированных компонентов, каждый из которых отвечает за конкретный аспект игры.

Ключевой архитектурный паттерн проекта - разделение основной игровой сцены на следующие компоненты:

1. **GridComponent** - Отображение игровой сетки
2. **GameSceneUIManager** - Управление UI-элементами
3. **GameSceneInputHandler** - Обработка пользовательского ввода
4. **GameSceneAnimator** - Управление анимациями
5. **GameSceneYandexHandler** - Интеграция с Яндекс.Играми

Эта структура обеспечивает:
- Чистое разделение обязанностей
- Улучшенную тестируемость
- Упрощенное сопровождение кода
- Возможность независимой модификации компонентов

## GridComponent

`GridComponent` отвечает за визуальное представление игровой сетки и всех взаимодействий с ней.

### Основные функции

1. **Создание и отрисовка сетки**:
   - Отрисовка фоновых линий сетки
   - Создание интерактивных блоков для каждой ячейки
   - Настройка обработчиков кликов

2. **Обновление визуального состояния сетки**:
   - Отображение размещенных фигур
   - Применение визуальных эффектов (3D-эффекты, блики, тени)
   - Очистка ячеек при необходимости

3. **Визуальные эффекты**:
   - Анимация очистки блоков с эффектами вспышки и частиц
   - Подсветка доступных позиций для размещения
   - Подсветка линий, которые будут очищены

4. **Обработка взаимодействий**:
   - Регистрация и вызов callback-функций при кликах на ячейки
   - Визуальная обратная связь при взаимодействии

### Ключевые методы

- `createGrid()`: Инициализирует игровую сетку
- `updateGrid(grid: Cell[][])`: Обновляет визуальное представление сетки
- `animateBlockClear(x: number, y: number)`: Анимирует очистку блока с визуальными эффектами
- `highlightValidPositions(shape: Shape | null, validPositions: GridPosition[])`: Подсвечивает доступные позиции
- `highlightCellsToBeCleaned(rows: number[], cols: number[])`: Подсвечивает линии, которые будут очищены
- `clearHighlights()`: Очищает все подсветки

### Пример использования

```typescript
// Создание компонента
const gridComponent = new GridComponent(scene);

// Установка обработчика кликов
gridComponent.setOnClick((position) => {
  // Обработка клика на позицию
  placeSelectedShape(position);
});

// Обновление сетки
gridComponent.updateGrid(gameState.grid);

// Анимация очистки блока
gridComponent.animateBlockClear(x, y);
```

## GameSceneUIManager

`GameSceneUIManager` отвечает за создание и управление всеми элементами пользовательского интерфейса в игровой сцене.

### Основные функции

1. **Создание UI-элементов**:
   - Инициализация GridComponent
   - Создание отображения счета и комбо
   - Создание области предпросмотра фигур
   - Добавление кнопок и других элементов управления

2. **Управление отображением информации**:
   - Обновление текста счета
   - Обновление текста комбо
   - Обновление предпросмотра фигур

3. **Визуальные эффекты UI**:
   - Анимация появления новых фигур
   - Эффекты подсветки активных элементов
   - Создание различных фоновых эффектов

### Ключевые методы

- `createUI()`: Создает все UI-элементы
- `updateScoreText(score: number)`: Обновляет отображение счета
- `updateComboText(combo: number)`: Обновляет отображение комбо
- `updateShapePreviews(shapes: (Shape | null)[], withAnimation?: boolean)`: Обновляет отображение доступных фигур
- `createShapePreview(shape: Shape, index: number)`: Создает отображение одной фигуры в области предпросмотра

### Взаимодействие с другими компонентами

- Хранит ссылку на `GridComponent`
- Получает доступ к `GameSceneAnimator` для анимаций
- Взаимодействует с `GameSceneInputHandler` опосредованно через основную сцену

## GameSceneInputHandler

`GameSceneInputHandler` отвечает за обработку всех пользовательских взаимодействий в игровой сцене.

### Основные функции

1. **Обработка выбора фигуры**:
   - Регистрация кликов на фигуры в области предпросмотра
   - Выбор фигуры для размещения

2. **Система drag-and-drop**:
   - Перетаскивание выбранной фигуры на игровое поле
   - Визуализация "призрака" фигуры при перетаскивании
   - Размещение фигуры при отпускании на допустимой позиции

3. **Обработка наведения**:
   - Отслеживание движения курсора/пальца
   - Обновление "призрака" фигуры при наведении на сетку
   - Визуальная обратная связь о возможности размещения

### Ключевые методы

- `setupInputHandlers()`: Настраивает все обработчики событий
- `enablePreviewDragging()`: Активирует возможность перетаскивания фигур из превью
- `onShapePreviewDown(shapeIndex: number)`: Обрабатывает нажатие на фигуру в превью
- `onDragMove(pointer: Phaser.Input.Pointer)`: Обрабатывает перемещение при перетаскивании
- `onDragEnd(pointer: Phaser.Input.Pointer)`: Обрабатывает окончание перетаскивания

### Особенности реализации

- Управляет внутренним состоянием перетаскивания (isDragging, draggedShapeIndex)
- Преобразует координаты экрана в координаты игровой сетки
- Предотвращает нежелательные действия во время окончания игры или анимаций

## GameSceneAnimator

`GameSceneAnimator` отвечает за все анимации и визуальные эффекты в игровой сцене.

### Основные функции

1. **Анимация очков**:
   - Отображение заработанных очков над очищенными линиями
   - Эффекты появления и исчезновения текста

2. **Анимация размещения фигуры**:
   - Визуальные эффекты при размещении фигуры на поле
   - Анимации появления блоков

3. **Эффекты для специальных событий**:
   - Анимации при достижении определенного количества очков
   - Визуальное оповещение о комбо-множителях

4. **Дополнительные визуальные эффекты**:
   - Декоративные эффекты фона
   - Анимированные частицы и вспышки

### Ключевые методы

- `showPointsAnimation(points: number, position: GridPosition)`: Показывает анимацию получения очков
- `animateShapePlacement(position: GridPosition, shape: Shape, callback: () => void)`: Анимирует размещение фигуры
- `createScoreFlyAnimation(value: number, x: number, y: number)`: Создает анимацию "улетающих" очков
- `createStars()`: Создает декоративные звезды на фоне

### Техники анимации

- Использование систем частиц Phaser
- Анимация через Phaser.Tweens для плавных переходов
- Комбинирование нескольких эффектов для создания сложных анимаций

## GameSceneYandexHandler

`GameSceneYandexHandler` отвечает за взаимодействие с SDK Яндекс.Игр из игровой сцены.

### Основные функции

1. **Управление рекламой**:
   - Показ rewarded-рекламы для получения бонусных фигур
   - Обработка колбэков рекламы (открытие, закрытие, награда, ошибка)

2. **Интеграция с таблицей лидеров**:
   - Отправка результатов игры в таблицу лидеров
   - Обработка успешных и неуспешных запросов

3. **Обработка данных игрока**:
   - Получение информации о пользователе
   - Сохранение игрового прогресса при необходимости

### Ключевые методы

- `showAdForBonusBlocks(callback?: () => void)`: Показывает rewarded-рекламу для получения бонусных фигур
- `sendLeaderboardScore(score: number)`: Отправляет счет в таблицу лидеров
- `savePlayerData(data: any)`: Сохраняет данные игрока

### Особенности реализации

- Защитные проверки доступности SDK и его методов
- Обработка всех возможных ошибок при работе с API
- Предоставление интерфейса для основной сцены, абстрагирующего детали взаимодействия с SDK

## Взаимодействие компонентов

Компоненты взаимодействуют между собой через основную игровую сцену (`GameSceneNew`), которая выступает в роли координатора:

1. **Инициализация компонентов**:
```typescript
this.animator = new GameSceneAnimator(this);
this.uiManager = new GameSceneUIManager(this, this.animator);
this.inputHandler = new GameSceneInputHandler(this);
this.yandexHandler = new GameSceneYandexHandler(this);
```

2. **Потоки взаимодействия**:
   - `InputHandler` -> `GameScene` -> `GameManager`: При выборе и размещении фигуры
   - `GameManager` -> `GameScene` -> `UIManager`/`Animator`: При обновлении состояния игры
   - `GameScene` -> `YandexHandler` -> `GameScene`: При показе рекламы и получении бонусов

3. **Система событий**:
   - `GameManager` уведомляет сцену через колбэки в интерфейсе `GameEvents`
   - Сцена делегирует обработку событий соответствующим компонентам

## Преимущества компонентной структуры

1. **Изоляция функциональности**:
   - Каждый компонент фокусируется на конкретной области
   - Изменения в одном компоненте минимально влияют на другие

2. **Упрощенное тестирование**:
   - Компоненты можно тестировать изолированно
   - Легче создавать моки для зависимостей

3. **Улучшенная читаемость кода**:
   - Чистое разделение обязанностей делает код более понятным
   - Легче отследить поток выполнения и взаимодействия

4. **Масштабируемость**:
   - Легко добавлять новые компоненты
   - Существующие компоненты можно развивать независимо

5. **Возможность повторного использования**:
   - Компоненты можно переиспользовать в других сценах или проектах
   - Обобщенная функциональность может быть вынесена в базовые классы