# Система компонентов

## Обзор компонентной структуры

Проект "Тетрис-блоки" использует компонентную архитектуру для разделения ответственности и улучшения поддерживаемости кода. Основная игровая сцена (`GameScene.ts`) координирует работу нескольких специализированных компонентов, каждый из которых отвечает за конкретный аспект игры.

Ключевой архитектурный паттерн проекта - разделение основной игровой сцены на следующие компоненты:

1. **GridComponent** - Отображение игровой сетки
2. **GameSceneUIManager** - Управление UI-элементами и их подкомпонентами
3. **GameSceneInputHandler** - Обработка пользовательского ввода
4. **GameSceneAnimator** - Управление анимациями
5. **GameSceneYandexHandler** - Интеграция с Яндекс.Играми
6. **GameSceneBackground** - Управление фоновыми эффектами
7. **GameSceneGridHandler** - Обработка взаимодействий с игровой сеткой

Эта структура обеспечивает:
- Чистое разделение обязанностей
- Улучшенную тестируемость
- Упрощенное сопровождение кода
- Возможность независимой модификации компонентов

## GridComponent

`GridComponent` отвечает за визуальное представление игровой сетки и всех взаимодействий с ней.

### Основные функции

1. **Создание и отрисовка сетки**:
   - Отрисовка фоновых линий сетки
   - Создание интерактивных блоков для каждой ячейки
   - Настройка обработчиков кликов

2. **Обновление визуального состояния сетки**:
   - Отображение размещенных фигур
   - Применение визуальных эффектов (3D-эффекты, блики, тени)
   - Очистка ячеек при необходимости

3. **Визуальные эффекты**:
   - Анимация очистки блоков с эффектами вспышки и частиц
   - Подсветка доступных позиций для размещения
   - Подсветка линий, которые будут очищены

4. **Обработка взаимодействий**:
   - Регистрация и вызов callback-функций при кликах на ячейки
   - Визуальная обратная связь при взаимодействии

### Ключевые методы

- `createGrid()`: Инициализирует игровую сетку
- `updateGrid(grid: Cell[][])`: Обновляет визуальное представление сетки
- `animateBlockClear(x: number, y: number)`: Анимирует очистку блока с визуальными эффектами
- `highlightValidPositions(shape: Shape | null, validPositions: GridPosition[])`: Подсвечивает доступные позиции
- `highlightCellsToBeCleaned(rows: number[], cols: number[])`: Подсвечивает линии, которые будут очищены
- `clearHighlights()`: Очищает все подсветки

### Пример использования

```typescript
// Создание компонента
const gridComponent = new GridComponent(scene);

// Установка обработчика кликов
gridComponent.setOnClick((position) => {
  // Обработка клика на позицию
  placeSelectedShape(position);
});

// Обновление сетки
gridComponent.updateGrid(gameState.grid);

// Анимация очистки блока
gridComponent.animateBlockClear(x, y);
```

## GameSceneUIManager

`GameSceneUIManager` отвечает за создание и управление всеми элементами пользовательского интерфейса в игровой сцене. Теперь он использует композицию и делегирует задачи специализированным подкомпонентам.

### Подкомпоненты

1. **GameSceneUIBackground** - отвечает за фоновые элементы UI
2. **GameSceneUIScoreDisplay** - управляет отображением счета и комбо
3. **GameSceneUIShapePreview** - отвечает за область предпросмотра фигур

### Основные функции

1. **Инициализация и координация подкомпонентов**:
   - Создание и инициализация всех подкомпонентов UI
   - Координация взаимодействия между ними
   - Инициализация GridComponent

2. **Делегирование управления отображением**:
   - Перенаправление запросов обновления счета в GameSceneUIScoreDisplay
   - Перенаправление запросов обновления комбо в GameSceneUIScoreDisplay
   - Перенаправление запросов обновления предпросмотра фигур в GameSceneUIShapePreview

3. **Предоставление доступа к UI-компонентам**:
   - Предоставление API для доступа к компонентам сетки и предпросмотра
   - Управление жизненным циклом UI-компонентов

### Ключевые методы

- `createUI()`: Создает все UI-элементы
- `updateScoreText(score: number)`: Обновляет отображение счета
- `updateComboText(combo: number)`: Обновляет отображение комбо
- `updateShapePreviews(shapes: (Shape | null)[], withAnimation?: boolean)`: Обновляет отображение доступных фигур
- `createShapePreview(shape: Shape, index: number)`: Создает отображение одной фигуры в области предпросмотра

### Взаимодействие с другими компонентами

- Хранит ссылки на все UI-подкомпоненты
- Хранит ссылку на `GridComponent` и предоставляет к нему доступ
- Получает доступ к `GameSceneAnimator` для анимаций
- Взаимодействует с `GameSceneInputHandler` опосредованно через основную сцену

## GameSceneInputHandler

`GameSceneInputHandler` отвечает за обработку всех пользовательских взаимодействий в игровой сцене.

### Основные функции

1. **Обработка выбора фигуры**:
   - Регистрация кликов на фигуры в области предпросмотра
   - Выбор фигуры для размещения

2. **Система drag-and-drop**:
   - Перетаскивание выбранной фигуры на игровое поле
   - Визуализация "призрака" фигуры при перетаскивании
   - Размещение фигуры при отпускании на допустимой позиции

3. **Обработка наведения**:
   - Отслеживание движения курсора/пальца
   - Обновление "призрака" фигуры при наведении на сетку
   - Визуальная обратная связь о возможности размещения

### Ключевые методы

- `setupInputHandlers()`: Настраивает все обработчики событий
- `enablePreviewDragging()`: Активирует возможность перетаскивания фигур из превью
- `onShapePreviewDown(shapeIndex: number)`: Обрабатывает нажатие на фигуру в превью
- `onDragMove(pointer: Phaser.Input.Pointer)`: Обрабатывает перемещение при перетаскивании
- `onDragEnd(pointer: Phaser.Input.Pointer)`: Обрабатывает окончание перетаскивания

### Особенности реализации

- Управляет внутренним состоянием перетаскивания (isDragging, draggedShapeIndex)
- Преобразует координаты экрана в координаты игровой сетки
- Предотвращает нежелательные действия во время окончания игры или анимаций

## GameSceneAnimator

`GameSceneAnimator` отвечает за все анимации и визуальные эффекты в игровой сцене.

### Основные функции

1. **Анимация очков**:
   - Отображение заработанных очков над очищенными линиями
   - Эффекты появления и исчезновения текста

2. **Анимация размещения фигуры**:
   - Визуальные эффекты при размещении фигуры на поле
   - Анимации появления блоков

3. **Эффекты для специальных событий**:
   - Анимации при достижении определенного количества очков
   - Визуальное оповещение о комбо-множителях

4. **Дополнительные визуальные эффекты**:
   - Декоративные эффекты фона
   - Анимированные частицы и вспышки

### Ключевые методы

- `showPointsAnimation(points: number, position: GridPosition)`: Показывает анимацию получения очков
- `animateShapePlacement(position: GridPosition, shape: Shape, callback: () => void)`: Анимирует размещение фигуры
- `createScoreFlyAnimation(value: number, x: number, y: number)`: Создает анимацию "улетающих" очков
- `createStars()`: Создает декоративные звезды на фоне

### Техники анимации

- Использование систем частиц Phaser
- Анимация через Phaser.Tweens для плавных переходов
- Комбинирование нескольких эффектов для создания сложных анимаций

## GameSceneYandexHandler

`GameSceneYandexHandler` отвечает за взаимодействие с SDK Яндекс.Игр из игровой сцены.

### Основные функции

1. **Управление рекламой**:
   - Показ rewarded-рекламы для получения бонусных фигур
   - Обработка колбэков рекламы (открытие, закрытие, награда, ошибка)

2. **Интеграция с таблицей лидеров**:
   - Отправка результатов игры в таблицу лидеров
   - Обработка успешных и неуспешных запросов

3. **Обработка данных игрока**:
   - Получение информации о пользователе
   - Сохранение игрового прогресса при необходимости

### Ключевые методы

- `showAdForBonusBlocks(callback?: () => void)`: Показывает rewarded-рекламу для получения бонусных фигур
- `sendLeaderboardScore(score: number)`: Отправляет счет в таблицу лидеров
- `savePlayerData(data: any)`: Сохраняет данные игрока

### Особенности реализации

- Защитные проверки доступности SDK и его методов
- Обработка всех возможных ошибок при работе с API
- Предоставление интерфейса для основной сцены, абстрагирующего детали взаимодействия с SDK

## GameSceneBackground

`GameSceneBackground` отвечает за создание и управление анимированным фоном игровой сцены.

### Основные функции

1. **Создание фоновых элементов**:
   - Генерация фона с градиентами и эффектами
   - Создание декоративных элементов (звезды, частицы)

2. **Анимация фоновых элементов**:
   - Управление движением частиц
   - Анимация цветовых эффектов
   - Пульсация и другие динамические эффекты

3. **Производительная обработка**:
   - Оптимизированное обновление в методе update
   - Корректное уничтожение ресурсов

## GameSceneGridHandler

`GameSceneGridHandler` отвечает за логику взаимодействия с игровой сеткой и размещение фигур.

### Основные функции

1. **Управление выбором фигур**:
   - Логика выбора текущей фигуры
   - Сохранение и обработка состояния выбранной фигуры

2. **Обработка размещения фигур**:
   - Проверка возможности размещения фигуры
   - Взаимодействие с GameManager для применения изменений
   - Визуализация "призрака" фигуры при наведении

3. **Координация взаимодействия**:
   - Связь между пользовательским вводом и логикой игры
   - Обработка ответов от GameManager и обновление UI

## Взаимодействие компонентов

Компоненты взаимодействуют между собой через основную игровую сцену (`GameScene`), которая выступает в роли координатора:

1. **Инициализация компонентов**:
```typescript
this.background = new GameSceneBackground(this);
this.animator = new GameSceneAnimator(this);
this.uiManager = new GameSceneUIManager(this, this.animator);
this.inputHandler = new GameSceneInputHandler(this);
this.yandexHandler = new GameSceneYandexHandler(this);
this.gridHandler = new GameSceneGridHandler(this, this.gameManager, this.animator);
```

2. **Потоки взаимодействия**:
   - `InputHandler` -> `GameScene` -> `GridHandler` -> `GameManager`: При выборе и размещении фигуры
   - `GameManager` -> `GameScene` -> `UIManager`/`Animator`: При обновлении состояния игры
   - `GameScene` -> `YandexHandler` -> `GameScene`: При показе рекламы и получении бонусов

3. **Система событий**:
   - `GameManager` уведомляет сцену через колбэки в интерфейсе `GameEvents`
   - Сцена делегирует обработку событий соответствующим компонентам

## Преимущества компонентной структуры

1. **Изоляция функциональности**:
   - Каждый компонент фокусируется на конкретной области
   - Изменения в одном компоненте минимально влияют на другие

2. **Упрощенное тестирование**:
   - Компоненты можно тестировать изолированно
   - Легче создавать моки для зависимостей

3. **Улучшенная читаемость кода**:
   - Чистое разделение обязанностей делает код более понятным
   - Легче отследить поток выполнения и взаимодействия

4. **Масштабируемость**:
   - Легко добавлять новые компоненты
   - Существующие компоненты можно развивать независимо

5. **Возможность повторного использования**:
   - Компоненты можно переиспользовать в других сценах или проектах
   - Обобщенная функциональность может быть вынесена в базовые классы

## Иммутабельное управление состоянием

В проекте внедрен иммутабельный подход к управлению состоянием игры через структуру из нескольких компонентов:

### StateUtils

Модуль `src/game/utils/StateUtils.ts` предоставляет утилиты для иммутабельной работы с состоянием:

1. **Безопасное копирование**:
   - `deepCopy<T>(obj: T): T` - создание глубокой копии объекта без JSON.stringify/parse
   - Оптимизированные методы для копирования вложенных структур

2. **Обновление объектов**:
   - `update<T extends object>(obj: T, updates: Partial<T>): T` - создание нового объекта с обновленными свойствами
   - Без мутации исходных данных

3. **Работа с массивами**:
   - `updateArrayItem<T>(array: T[], index: number, newItem: T): T[]` - создание нового массива с замененным элементом
   - Иммутабельные методы манипуляции с массивами

4. **Специализированные функции для игровой сетки**:
   - `updateGrid<T>(grid: T[][], x: number, y: number, value: T): T[][]` - обновление ячейки без мутации
   - `updateGridCells<T>(grid: T[][], updates: {x, y, value}[]): T[][]` - массовое обновление ячеек

### GameLogic

Компонент `GameLogic` реализует чистые функции для игровой логики:

- Все методы не мутируют входные данные
- Возвращают новые объекты с примененными изменениями
- Используют функциональный подход к обработке данных

### GameStateManager

Компонент `GameStateManager` обеспечивает централизованное управление состоянием:

- Все обновления состояния создают новые объекты
- Старые версии состояния не модифицируются
- Поддерживает атомарные обновления нескольких свойств

### Преимущества иммутабельного подхода

1. **Предсказуемость**:
   - Отсутствие побочных эффектов от непреднамеренных мутаций
   - Четкий и контролируемый поток изменения данных

2. **Улучшенная отладка**:
   - Легко отследить, когда и как меняется состояние
   - Возможность реализации функций типа "отмена/повтор"

3. **Функциональная парадигма**:
   - Чистые функции, которые не имеют состояния
   - Одинаковые входные данные всегда дают одинаковый результат

4. **Надежность**:
   - Снижение количества ошибок, связанных с неожиданными изменениями состояния
   - Более предсказуемое поведение приложения