# Технический стек проекта Тетрис-блоки

## Основные технологии

### Языки программирования
- **TypeScript**: Используется для всей кодовой базы, предоставляя статическую типизацию и современные возможности JavaScript.

### Фреймворки
- **React**: Используется для оболочки приложения и управления состоянием UI.
- **Phaser 3**: Игровой движок, который обеспечивает рендеринг, анимации, обработку пользовательского ввода и другие игровые функции.

### Интеграции
- **Яндекс Games SDK**: Используется для интеграции с платформой Яндекс.Игры, предоставляя функции таблицы лидеров, рекламы, аналитики и данных игрока.

## Ключевые библиотеки и зависимости

- **Create React App**: Используется как основа для React-части проекта.
- **Phaser 3**: Полнофункциональный игровой движок с поддержкой WebGL и Canvas.
- **TypeScript**: Надмножество JavaScript, добавляющее статическую типизацию.

## Архитектура приложения

Проект использует многослойную архитектуру, разделяющую ответственность между различными компонентами:

1. **React-слой (Оболочка)**
   - `App.tsx`: Корневой компонент, рендерит игру
   - `PhaserGame.tsx`: React-компонент, который монтирует и управляет экземпляром Phaser

2. **Phaser-слой (Игровой движок)**
   - `Game.ts`: Основной класс, инициализирующий Phaser и сцены
   - `config.ts`: Конфигурация игры, включая размеры, цвета и настройки

3. **Сцены Phaser**
   - `PreloadScene.ts`: Инициализация SDK и экран загрузки
   - `MenuScene.ts`: Главное меню игры
   - `GameSceneNew.ts`: Основная игровая сцена
   - `LeaderboardScene.ts`: Отображение таблицы лидеров

4. **Менеджеры для GameScene**
   - `GameSceneUIManager`: Управление UI-элементами
   - `GameSceneInputHandler`: Обработка пользовательского ввода
   - `GameSceneAnimator`: Управление анимациями
   - `GameSceneYandexHandler`: Взаимодействие с Яндекс.SDK

5. **Игровая логика**
   - `GameManager.ts`: Управление игровым состоянием и логикой
   - `ShapeGenerator.ts`: Генерация игровых фигур

6. **Компоненты Phaser**
   - `GridComponent.ts`: Визуальное представление игровой сетки
   - Другие компоненты для UI и игрового процесса

## Структура компонентов

### Ключевые компоненты и их ответственность

#### GameManager
- Управляет состоянием игры
- Обрабатывает игровую логику (размещение фигур, очистка линий)
- Обрабатывает события (обновление счета, окончание игры)
- Генерирует новые фигуры

#### GridComponent
- Отвечает за визуальное представление игровой сетки
- Рендерит блоки и линии сетки
- Управляет анимациями очистки блоков
- Подсвечивает доступные позиции для размещения фигур

#### GameSceneUIManager
- Создает и управляет UI-элементами
- Обновляет визуальное представление счета и комбо
- Управляет отображением фигур в превью

#### GameSceneInputHandler
- Обрабатывает пользовательский ввод
- Управляет drag-and-drop фигур
- Обновляет "призрак" фигуры при перемещении

#### GameSceneAnimator
- Управляет различными анимациями в игре
- Анимирует появление очков
- Создает визуальные эффекты при размещении фигур

#### GameSceneYandexHandler
- Управляет взаимодействием с Яндекс Games SDK
- Показывает rewarded-рекламу для получения бонусных фигур

### Паттерны проектирования

1. **Component Pattern**: Компоненты с одной ответственностью (GridComponent, ShapePreview)

2. **Observer Pattern**: Используется через систему событий GameEvents для коммуникации между GameManager и сценой

3. **Factory Pattern**: ShapeGenerator для создания различных типов фигур

4. **Facade Pattern**: GameManager представляет собой фасад к игровой логике

5. **Manager Pattern**: Разделение ответственности через специализированные менеджеры (UIManager, InputHandler, Animator)

## Система типов

В проекте определены различные интерфейсы и типы для обеспечения типобезопасности:

- `GridPosition`: Позиция в сетке (x, y)
- `Cell`: Ячейка на игровой доске (filled, color)
- `ShapeType`: Перечисление типов фигур
- `Shape`: Структура игровой фигуры
- `GameState`: Состояние игры
- `ClearResult`: Результаты очистки линий
- `GameEvents`: Интерфейс для событий игры

Эта система типов обеспечивает четкие контракты между компонентами и помогает избежать ошибок времени выполнения.